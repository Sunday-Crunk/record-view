/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@air-apps/air-js/lib/air.js":
/*!**************************************************!*\
  !*** ./node_modules/@air-apps/air-js/lib/air.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AirComponent: () => (/* binding */ AirComponent),\n/* harmony export */   Router: () => (/* binding */ Router),\n/* harmony export */   airCss: () => (/* binding */ airCss),\n/* harmony export */   clearQueryCache: () => (/* binding */ clearQueryCache),\n/* harmony export */   createQuery: () => (/* binding */ createQuery),\n/* harmony export */   createState: () => (/* binding */ createState),\n/* harmony export */   globalState: () => (/* binding */ globalState),\n/* harmony export */   html: () => (/* binding */ html),\n/* harmony export */   invalidateQueries: () => (/* binding */ invalidateQueries),\n/* harmony export */   keyframes: () => (/* binding */ keyframes),\n/* harmony export */   onMount: () => (/* binding */ onMount),\n/* harmony export */   onUnMount: () => (/* binding */ onUnMount),\n/* harmony export */   state: () => (/* binding */ state),\n/* harmony export */   strict: () => (/* binding */ strict),\n/* harmony export */   style: () => (/* binding */ style)\n/* harmony export */ });\n\r\nconst html = (strings, ...values) => {\r\n  //console.log(\"v: \", values)\r\n  return {\r\n    strings,\r\n    values,\r\n    htmlTemplate:true\r\n  }\r\n};\r\n\r\nconst FocusManager = {\r\n  focusPath: null,\r\n  focusAttributes: null,\r\n  setFocusAttributes(attributes){\r\n    this.focusAttributes = attributes\r\n  },\r\n  setFocusPath(path) {\r\n      this.focusPath = path;\r\n  },\r\n  getPathToElement(element){\r\n    const path = [];\r\n    while (element && element !== document.body) {\r\n        const parent = element.parentNode;\r\n        const index = Array.prototype.indexOf.call(parent.children, element);\r\n        path.unshift(index);\r\n        element = parent;\r\n    }\r\n    return path;\r\n  },\r\n  restoreFocus() {\r\n      let element = document.body;\r\n      for (const index of this.focusPath) {\r\n    \r\n          if (!element || index > element.children.length) return;\r\n          element = element.children[index];\r\n      }\r\n      if (element) {\r\n\r\n          element.focus();\r\n          \r\n          this.focusAttributes?.forEach(a=>{\r\n            //first handling special attributes like caret position\r\n            if (a.name === \"selectionStart\" && a.value > 0){ \r\n              element.selectionStart = a.value    \r\n            }\r\n          })\r\n      }\r\n      this.focusAttributes = null;\r\n  }\r\n};\r\n\r\n\r\nlet performanceReports = [];\r\n\r\nconst monitorPerformance = (reportThreshold, monitorInterval, performanceDegradationThreshold) => {\r\n  const generateStatusReport = () => {\r\n    let totalTasks = 0, totalDeferred = 0, totalExecuted = 0;\r\n    performanceReports.forEach(report => {\r\n      totalTasks += report.total;\r\n      totalDeferred += report.deferred;\r\n      totalExecuted += report.executed;\r\n    });\r\n\r\n    const averageTime = performanceReports.reduce((acc, report) => acc + report.time, 0) / performanceReports.length;\r\n    console.log(`Status Report: ${performanceReports.length} reports, Total: ${totalTasks}, Deferred: ${totalDeferred}, Executed: ${totalExecuted}, Average time: ${averageTime.toFixed(2)}ms`);\r\n  };\r\n\r\n  const checkForPerformanceDegradation = () => {\r\n    const degradationReports = performanceReports.filter(report => report.time > performanceDegradationThreshold);\r\n    if (degradationReports.length > 0) {\r\n      performanceReports = [];\r\n      console.warn(`Performance Degradation Detected: ${degradationReports.length} reports exceeding ${performanceDegradationThreshold}ms`);\r\n    }\r\n  };\r\n\r\n  setInterval(() => {\r\n    const reportSize = performanceReports.length;\r\n    if (reportSize >= reportThreshold) {\r\n      generateStatusReport();\r\n      performanceReports.splice(0, reportSize);\r\n    }\r\n    checkForPerformanceDegradation();\r\n  }, monitorInterval);\r\n};\r\n\r\nconst REPORT_THRESHOLD = 200;\r\nconst MONITOR_INTERVAL = 5000;\r\nconst PERFORMANCE_DEGRADATION_THRESHOLD = 2;\r\n\r\nmonitorPerformance(REPORT_THRESHOLD, MONITOR_INTERVAL, PERFORMANCE_DEGRADATION_THRESHOLD);\r\nclass RenderManager {\r\n    constructor(timeLimit = 150, debounceTime = 10) {\r\n    this.primaryQueue = [];\r\n    this.secondaryQueue = [];\r\n    this.renderScheduled = false;\r\n    this.timeLimit = timeLimit;\r\n    this.batchedUpdates = new Set();\r\n    this.isBatchingUpdates = false;\r\n    this.componentUpdates = new Map();\r\n    this.debounceTime = debounceTime;\r\n    this.debounceTimer = null;\r\n    this.componentSet = new Set();\r\n  }\r\n\r\n  addPrimaryRender(fn) {\r\n    if (!this.componentSet.has(currentComponent)) {\r\n      this.componentSet.add(currentComponent);\r\n      this.batchedUpdates.add(() => {\r\n        fn();\r\n        this.componentSet.delete(currentComponent);\r\n      });\r\n      this.scheduleBatchedRender();\r\n    }\r\n  }\r\n\r\n  addSecondaryRender(fn) {\r\n    this.secondaryQueue.push(fn);\r\n    this.scheduleBatchedRender();\r\n  }\r\n\r\n  scheduleBatchedRender() {\r\n    if (!this.isBatchingUpdates) {\r\n      this.isBatchingUpdates = true;\r\n      Promise.resolve().then(() => this.flushBatchedUpdates());\r\n    }\r\n  }\r\n\r\n  flushBatchedUpdates() {\r\n    this.primaryQueue = Array.from(this.batchedUpdates);\r\n    this.batchedUpdates.clear();\r\n    this.componentSet.clear();\r\n    this.executeRenderImmediately();\r\n    this.isBatchingUpdates = false;\r\n  }\r\n\r\n  executeRenderImmediately() {\r\n    const startTime = performance.now();\r\n    let executedTasks = 0;\r\n    \r\n    while (this.primaryQueue.length > 0 && performance.now() - startTime < this.timeLimit) {\r\n      const task = this.primaryQueue.shift();\r\n      task();\r\n      executedTasks++;\r\n    }\r\n\r\n    const endTime = performance.now();\r\n    performanceReports.push({\r\n      total: executedTasks + this.primaryQueue.length,\r\n      deferred: this.primaryQueue.length,\r\n      executed: executedTasks,\r\n      time: endTime - startTime\r\n    });\r\n\r\n    if (this.primaryQueue.length > 0 || this.secondaryQueue.length > 0) {\r\n      this.scheduleRender();\r\n    }\r\n  }\r\n\r\n  scheduleRender() {\r\n    if (!this.renderScheduled) {\r\n      this.renderScheduled = true;\r\n      requestAnimationFrame(() => {\r\n        this.executeTasks(this.primaryQueue, 'primary');\r\n        this.executeTasks(this.secondaryQueue, 'secondary');\r\n        this.renderScheduled = false;\r\n      });\r\n    }\r\n  }\r\n\r\n  executeTasks(queue, queueType) {\r\n    const startTime = performance.now();\r\n    let executedTasks = 0;\r\n    while (queue.length > 0 && performance.now() - startTime < this.timeLimit) {\r\n      const task = queue.shift();\r\n      task();\r\n      executedTasks++;\r\n    }\r\n    const endTime = performance.now();\r\n    performanceReports.push({\r\n      total: executedTasks + queue.length,\r\n      deferred: queue.length,\r\n      executed: executedTasks,\r\n      time: endTime - startTime,\r\n      queueType\r\n    });\r\n    if (queue.length > 0) {\r\n      this.scheduleRender();\r\n    }\r\n  }\r\n}\r\n\r\nconst renderManager = new RenderManager;\r\n\r\nclass ReactiveState {\r\n  constructor(initialValue) {\r\n    let value = initialValue;\r\n    this.subscribers = new Map(); // Map of components to their subscribers\r\n    this.onUpdateSubscribers = new Set();\r\n    this.prev = null;\r\n    this.trim = () => value.trim();\r\n    this.id = Math.random().toString(36).substring(2, 10).trim()\r\n    this.map = (renderFunc) => {\r\n      const total = value.map((v, i) => renderFunc(v, i));\r\n      const getter = () => {\r\n        const total = [];\r\n        value.forEach(v => {  \r\n          const {strings, values} = renderFunc(v);\r\n          const renderedItem = currentComponent.processTemplate(strings, values);\r\n          total.push(renderedItem);\r\n        });\r\n        return total.join('');  \r\n      };\r\n\r\n      return total.every(item => item && item.htmlTemplate) ? { get: getter, isStateArray: true } : total;\r\n    };\r\n\r\n    this.read = (x) => {\r\n      const effect = getCurrentEffect();\r\n      if (effect) {\r\n        const component = currentComponent;\r\n        if (!this.subscribers.has(component)) {\r\n          this.subscribers.set(component, new Set());\r\n        }\r\n        this.subscribers.get(component).add(effect);\r\n      }\r\n      return value;\r\n    };\r\n\r\n    this.onUpdate = (handler) => this.onUpdateSubscribers.add(handler);\r\n\r\n    this.write = (newValue, proxy, options) => {\r\n      this.prev = value;\r\n      if (typeof newValue === 'function') {\r\n        newValue = newValue(value);\r\n      }\r\n      if (newValue !== value) {\r\n        value = newValue;\r\n        if (renderManager) {\r\n          if (this.subscribers.size > 0){\r\n            renderManager.addPrimaryRender(() => {\r\n              this.subscribers.forEach((componentSubscribers, component) => {\r\n                componentSubscribers.forEach(sub => sub(value, this.prev ));\r\n              });\r\n            });\r\n          }\r\n          if (this.onUpdateSubscribers.size > 0){\r\n            renderManager.addSecondaryRender(() => {\r\n              this.onUpdateSubscribers.forEach(sub => sub(value));\r\n            });\r\n          }\r\n        }\r\n      }\r\n    };\r\n    this.removeComponentSubscribers = (component) => {\r\n      this.subscribers.delete(component);\r\n    };\r\n\r\n    this[Symbol.toPrimitive] = (hint) => {\r\n      return hint === 'string' ? String(this.read()) : (hint === 'number' ? Number(this.read()) : this.read());\r\n    };\r\n  }\r\n}\r\n\r\nconst componentStateMap = new WeakMap();\r\nlet airGlobalStateHeap = null;\r\nconst createSignal = (initialValue, options) => {\r\n  const state = new ReactiveState(initialValue);\r\n  \r\n  \r\n  // Define a function to act as the target for the proxy\r\n  const targetFunction = function() {\r\n    return state.read(); // Or any logic you want when the proxy is called as a function\r\n  };\r\n\r\n  // Attach the state instance to the function\r\n  targetFunction.state = state;\r\n\r\n  const proxy = new Proxy(targetFunction, {\r\n    apply(target, thisArg, argumentsList) {\r\n      // Call the target function\r\n      return target.apply(thisArg, argumentsList);\r\n    },\r\n\r\n    get(target, prop, receiver) {\r\n      try {\r\n        if (prop === Symbol.toPrimitive) {\r\n          return target.state[Symbol.toPrimitive].bind(target.state);\r\n        }\r\n          // if prop = \"revert\" send previous value\r\n        if (prop === 'revert'){\r\n          target.state.write(target.state.prev)\r\n          return (...args)=>{\r\n           if (args?.length === 1 && typeof args[0] === \"function\"){\r\n            args[0]()\r\n           }else if (args?.length !== 0){\r\n            throw new Error(\"Invalid revert callback argument. Must be a function.\")\r\n           }\r\n          };\r\n        }\r\n        if (prop === 'valueOf') {\r\n  \r\n          return () => target.state.read();\r\n        }\r\n\r\n        if (prop === 'state') {\r\n          return target.state;\r\n        }\r\n\r\n        const currentValue = target.state.read();\r\n\r\n        // Handle the case when `myVar` is accessed directly\r\n        if (prop === 'then') {\r\n          // To ensure compatibility with Promise-like behavior\r\n          return undefined;\r\n        }\r\n\r\n        if (prop === 'trim') {\r\n          return target.state.trim;\r\n        }\r\n\r\n        if (prop === 'onUpdate') {\r\n          return target.state.onUpdate;\r\n        }\r\n\r\n        if (currentValue && typeof currentValue === 'object') {\r\n          if (prop in currentValue) {\r\n            const property = target.state.read()[prop];\r\n            return typeof property === 'function' ? property.bind(currentValue) : property;\r\n          }\r\n        }\r\n        \r\n        if (prop === 'toLowerCase' && typeof currentValue === 'string') {\r\n          return () => currentValue.toLowerCase();\r\n        }\r\n\r\n        // Check if the property exists on the target function itself\r\n        if (prop in target) {\r\n          return target[prop];\r\n        }\r\n\r\n        // Default case: return the current value\r\n        // Handle other property access or methods\r\n      return Reflect.get(...arguments);\r\n        return currentValue;\r\n      } catch (error) {\r\n        console.error(\"Error accessing property:\", prop, error);\r\n        throw error; // Optionally rethrow or handle the error differently\r\n      }\r\n    }\r\n  });\r\n\r\n  if(options){ \r\n    const system = options?.global //avoid conflict with node window keyword\r\n    if (system) {\r\n      airGlobalStateHeap = airGlobalStateHeap || new Map();\r\n      airGlobalStateHeap.set(system, [proxy, (newValue) => {\r\n        state.write(newValue);\r\n      }]);\r\n      \r\n      // Associate the current component with this global state\r\n      if (currentComponent) {\r\n        if (!componentStateMap.has(currentComponent)) {\r\n          componentStateMap.set(currentComponent, new Set());\r\n        }\r\n        componentStateMap.get(currentComponent).add(system);\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  return [proxy, (newValue) => {\r\n    state.write(newValue, proxy, options);\r\n  }];\r\n};\r\n\r\nclass DerivedState {\r\n  constructor(fn, state) {\r\n    this.fn = fn;\r\n    this.state = state;\r\n  }\r\n  get() {\r\n    return this.fn(this.state.read());\r\n  }\r\n}\r\n\r\nconst airSignal = (initialValue, options) => {\r\n  const state = new ReactiveState(initialValue);\r\n  \r\n  // Define a function to act as the target for the proxy\r\n  const targetFunction = function(elementId) {\r\n    return state.read(elementId); // Or any logic you want when the proxy is called as a function\r\n  };\r\n\r\n  // Attach the state instance to the function\r\n  targetFunction.state = state;\r\n\r\n  const proxy = new Proxy(targetFunction, {\r\n    apply(target, thisArg, argumentsList) {\r\n      // Call the target function\r\n      return target.apply(thisArg, argumentsList);\r\n    },\r\n\r\n    get(target, prop, receiver) {\r\n      try {\r\n        if (prop === Symbol.toPrimitive) {\r\n          return target.state[Symbol.toPrimitive].bind(target.state);\r\n        }\r\n        // if prop = \"revert\" send previous value\r\n        if (prop === 'revert') {\r\n          target.state.write(target.state.prev)\r\n          return (...args) => {\r\n            if (args?.length === 1 && typeof args[0] === \"function\") {\r\n              args[0]()\r\n            } else if (args?.length !== 0) {\r\n              throw new Error(\"Invalid revert callback argument. Must be a function.\")\r\n            }\r\n          };\r\n        }\r\n        if (prop === 'valueOf') {\r\n          return () => target.state.read();\r\n        }\r\n        if (prop === 'state') {\r\n          return target.state;\r\n        }\r\n        if (prop === 'set') {\r\n          return (newValue) => {\r\n            state.write(newValue, proxy, options);\r\n          };\r\n        }\r\n\r\n        if (prop === 'derive') {\r\n          return (fn) => {\r\n            return new DerivedState(fn, target.state);\r\n          };\r\n        }\r\n\r\n        const currentValue = target.state.read();\r\n\r\n        // Handle the case when `myVar` is accessed directly\r\n        if (prop === 'then') {\r\n          // To ensure compatibility with Promise-like behavior\r\n          return undefined;\r\n        }\r\n        if (prop === 'trim') {\r\n          return target.state.trim;\r\n        }\r\n        if (prop === 'onUpdate') {\r\n          return target.state.onUpdate;\r\n        }\r\n        if (currentValue && typeof currentValue === 'object') {\r\n          if (prop in currentValue) {\r\n            const property = target.state.read()[prop];\r\n            return typeof property === 'function' ? property.bind(currentValue) : property;\r\n          }\r\n        }\r\n        if (prop === 'toLowerCase' && typeof currentValue === 'string') {\r\n          return () => currentValue.toLowerCase();\r\n        }\r\n        // Check if the property exists on the target function itself\r\n        if (prop in target) {\r\n          return target[prop];\r\n        }\r\n        // Default case: return the current value\r\n        // Handle other property access or methods\r\n        return Reflect.get(...arguments);\r\n      } catch (error) {\r\n        console.error(\"Error accessing property:\", prop, error);\r\n        throw error; // Optionally rethrow or handle the error differently\r\n      }\r\n    }\r\n  });\r\n\r\n  if (options) { \r\n    const system = options?.global // avoid conflict with node window keyword\r\n    if (system) {\r\n      airGlobalStateHeap = airGlobalStateHeap || new Map();\r\n      airGlobalStateHeap.set(system, proxy);\r\n      \r\n      // Associate the current component with this global state\r\n      if (currentComponent) {\r\n        if (!componentStateMap.has(currentComponent)) {\r\n          componentStateMap.set(currentComponent, new Set());\r\n        }\r\n        componentStateMap.get(currentComponent).add(system);\r\n      }\r\n    }\r\n  }\r\n\r\n  return proxy;\r\n};\r\n\r\nconst allStates = new Set();\r\nconst createState = (initialValue, options) => {\r\n  if (options && typeof options !== \"object\") {\r\n    throw new Error(\"Invalid argument: createState options must be an object.\");\r\n  } else if (options?.temporal && typeof options.temporal !== \"boolean\") {\r\n    throw new Error(`Invalid createState temporal parameter: options.temporal must be boolean, got ${typeof options.temporal}`);\r\n  } else if (options?.global && typeof options.global !== \"string\") {\r\n    throw new Error(`Invalid createState global parameter: options.global must be the global ID as a string, got ${typeof options.global}`);\r\n  }\r\n  \r\n  const [value, setValue] = createSignal(initialValue, options);\r\n\r\n  // Track local states\r\n  if (currentComponent && !options?.global) {\r\n    if (!currentComponent.localStates) {\r\n      currentComponent.localStates = new Set();\r\n    }\r\n    currentComponent.localStates.add(value.state);\r\n  }\r\n  if (!allStates.has(value.state)){\r\n    allStates.add(value.state)\r\n  }\r\n  return [value, setValue];\r\n};\r\n\r\nconst state = (initialValue, options) => {\r\n  if (options && typeof options !== \"object\") {\r\n    throw new Error(\"Invalid argument: createState options must be an object.\");\r\n  } else if (options?.temporal && typeof options.temporal !== \"boolean\") {\r\n    throw new Error(`Invalid createState temporal parameter: options.temporal must be boolean, got ${typeof options.temporal}`);\r\n  } else if (options?.global && typeof options.global !== \"string\") {\r\n    throw new Error(`Invalid createState global parameter: options.global must be the global ID as a string, got ${typeof options.global}`);\r\n  }\r\n  \r\n  const value= airSignal(initialValue, options);\r\n\r\n  // Track local states\r\n  if (currentComponent && !options?.global) {\r\n    if (!currentComponent.localStates) {\r\n      currentComponent.localStates = new Set();\r\n    }\r\n    currentComponent.localStates.add(value.state);\r\n  }\r\n  if (!allStates.has(value.state)){\r\n    allStates.add(value.state)\r\n  }\r\n  return value;\r\n};\r\n\r\nconst createEffect = (fn) => {\r\n  //console.log(\"creating effect: \", fn)\r\n  const execute = () => {\r\n    cleanupEffect();\r\n    setCurrentEffect(execute);\r\n    fn();\r\n    setCurrentEffect(null);\r\n  };\r\n  const cleanupEffect = () => {\r\n    // Logic to remove old effects or clean up resources\r\n    if (currentEffect && currentEffect.cleanup) {\r\n\r\n      currentEffect.cleanup();\r\n    }\r\n  };\r\n  execute();\r\n  return { cleanup: cleanupEffect };\r\n};\r\n\r\nlet currentEffect = null;\r\nconst setCurrentEffect = (effect) => {\r\n  currentEffect = effect;\r\n};\r\n\r\nconst getCurrentEffect = () => currentEffect;\r\n\r\n// Use `instanceof` to check if it is reactive state\r\nconst isReactiveState = (value) => value instanceof ReactiveState;\r\n\r\nconst globalState = (id) => {\r\n  if (!airGlobalStateHeap) {\r\n    throw new Error(\"Global stateheap not initialised, cannot retrieve any values\");\r\n  } else if (airGlobalStateHeap.has(id)) {\r\n    // Associate the current component with this global state\r\n    if (currentComponent) {\r\n      if (!componentStateMap.has(currentComponent)) {\r\n        componentStateMap.set(currentComponent, new Set());\r\n      }\r\n      componentStateMap.get(currentComponent).add(id);\r\n    }\r\n    return airGlobalStateHeap.get(id);\r\n  } else {\r\n    throw new Error(\"Could not find a value in the global stateheap with the ID: \" + id);\r\n  }\r\n};\r\n\r\nlet currentComponent = null;\r\nconst setCurrentComponent = (component) => {\r\n  currentComponent = component;\r\n};\r\nfunction analyzeCode(code, strictMode = false) {\r\n  const createStateRegex = /const \\[([a-zA-Z0-9_]+),/g;\r\n  let variables = [];\r\n\r\n  let match;\r\n  while ((match = createStateRegex.exec(code)) !== null) {\r\n    variables.push(match[1]);\r\n  }\r\n\r\n  let usageResults = {};\r\n  variables.forEach(variable => {\r\n    const regex = new RegExp(`\\\\b${variable}\\\\b(?!\\\\()`, 'g');\r\n    let firstOccurrence = true;\r\n    let usages = [];\r\n\r\n    while ((match = regex.exec(code)) !== null) {\r\n      if (firstOccurrence) {\r\n        firstOccurrence = false;\r\n        continue;\r\n      }\r\n\r\n      const position = match.index;\r\n      const postVarIndex = position + variable.length;\r\n      const postVarSnippet = code.slice(postVarIndex).trimStart();\r\n      const nextChar = postVarSnippet[0];\r\n\r\n      // Determine validity based on strict or non-strict mode\r\n      let isValid = true; // Assume valid by default\r\n      if (strictMode) {\r\n        isValid = nextChar === '('; // In strict mode, all usages must invoke\r\n      } else {\r\n        // Non-strict mode only concerns logical operations and equality checks\r\n        isValid = !(/\\s*(\\?|&&|\\|\\||==|!=)/.test(postVarSnippet)); // Check for risky logical or equality usage\r\n        if (/[\\+\\-\\*\\/]/.test(postVarSnippet.trim()[0])) {\r\n          isValid = true; // Allow arithmetic operations in non-strict mode\r\n        }\r\n      }\r\n\r\n      // Find the full line by searching for nearest line breaks around the match\r\n      let start = code.lastIndexOf('\\n', position - 1) + 1;\r\n      let end = code.indexOf('\\n', position);\r\n      if (end === -1) { end = code.length; } // Handle case where no newline at end\r\n      let snippet = code.substring(start, end);\r\n\r\n      usages.push({\r\n        position: position,\r\n        valid: isValid,\r\n        snippet: snippet\r\n      });\r\n    }\r\n    usageResults[variable] = usages;\r\n  });\r\n\r\n  return usageResults;\r\n}\r\n\r\n\r\nfunction logErrors(filteredObject, strict) {\r\n  Object.entries(filteredObject).forEach(([key, errors]) => {\r\n    errors.forEach(error => {\r\n      if (!strict) console.warn(`Warning: Uninvoked proxy usage detected with ${key}. Proxies should be invoked in logical and equality operations to ensure correct behavior. (Position ${error.position}): ${error.snippet}`);\r\n      else console.error(`Error: Detected uninvoked proxy. Proxies must be invoked on every access in strict mode. (Position ${error.position}): ${error.snippet}`\r\n    )\r\n    });\r\n  });\r\n}\r\n\r\nconst onMount = (f) => {\r\n  if (f && typeof f === \"function\") {\r\n    currentComponent.onMountCallbacks.push(f);\r\n  }else{\r\n    throw new Error(\"Invalid onMount function. Expected function, got: \" + typeof f);\r\n  }\r\n};\r\n\r\nconst onUnMount = (f) => {\r\n  if (f && typeof f === \"function\") {\r\n    currentComponent.onUnMountCallbacks.push(f);\r\n  }else{\r\n    throw new Error(\"Invalid onMount function. Expected function, got: \" + typeof f);\r\n  }\r\n};\r\n\r\n/**\r\n// Global interval tracking\r\nconst intervalTracker = new WeakMap();\r\nconst originalSetInterval = window.setInterval;\r\nconst originalClearInterval = window.clearInterval;\r\n\r\nwindow.setInterval = function(...args) {\r\n  const id = originalSetInterval.apply(this, args);\r\n  const component = currentComponent; // Implement this function to get the current component\r\n  if (component) {\r\n    if (!intervalTracker.has(component)) {\r\n      intervalTracker.set(component, new Set());\r\n    }\r\n    intervalTracker.get(component).add(id);\r\n  }\r\n  return id;\r\n};\r\n\r\nwindow.clearInterval = function(id) {\r\n  originalClearInterval.call(this, id);\r\n  for (const [component, intervals] of intervalTracker) {\r\n    if (intervals.has(id)) {\r\n      intervals.delete(id);\r\n      if (intervals.size === 0) {\r\n        intervalTracker.delete(component);\r\n      }\r\n      break;\r\n    }\r\n  }\r\n};\r\n**/\r\n // Cache frequently used regular expressions\r\nconst regexps = {\r\n  onEventRegex: /on\\w+=(\"?)(?<!\\w)$/,\r\n  tagMatchRegex: /<([^\\s>/]+)[^>]*$/,\r\n  attributeMatchRegex: /\\s(\\w+)=/g,\r\n  routeTagRegex: /<\\/?(?:route|router)\\b/g\r\n}\r\nconst globalProps = new Map();\r\nconst AirComponent = (elementName, component) => {\r\n\r\n  class CustomElement extends HTMLElement { \r\n\r\n    static usedPropIds = new Set();\r\n    static elementPropMap = new WeakMap();\r\n    static currentPropIds = new Set();\r\n    constructor() {\r\n      super();\r\n      \r\n      //this.checkProps()\r\n      this.routes = null;\r\n      this.state = new Map();\r\n      this.eventHandlers = new Map();\r\n      this.onMountCallbacks = [];\r\n      this.onUnMountCallbacks = [];\r\n      this.isInitialRender = true;  // Flag to check if it's the first render\r\n      this.psuedoStylesheet = \"\"\r\n      this.previousVdom = null;\r\n      this.currentVdom = null;\r\n      this.focusElement = null;\r\n      this.historyLength = 10\r\n      this.timeWalk = false;\r\n      //this.renderManager = new RenderManager;\r\n      this.strict = false;\r\n      this.sheet = new CSSStyleSheet();\r\n      this.childContent = null;\r\n\r\n      this.props = {}\r\n    }\r\n    static checkProps(element) {\r\n      const id = element.getAttribute(\"air_props_id\");\r\n      if (id) {\r\n        element.props = {...element.props, ...globalProps.get(id)};\r\n        CustomElement.usedPropIds.add(id);\r\n        CustomElement.elementPropMap.set(element, id);\r\n        CustomElement.currentPropIds.add(id);\r\n      }\r\n    }\r\n    static scheduleCleanup() {\r\n      requestAnimationFrame(() => {\r\n        CustomElement.cleanProps();\r\n      });\r\n    }\r\n    static cleanProps() {\r\n      globalProps.forEach((value, key) => {\r\n        if (!CustomElement.currentPropIds.has(key)) {\r\n          globalProps.delete(key);\r\n        }\r\n      });\r\n      CustomElement.usedPropIds.clear();\r\n      CustomElement.currentPropIds.clear();\r\n    }\r\n  \r\n    static scheduleCleanup() {\r\n      // Schedule cleanup for the next frame\r\n      requestAnimationFrame(() => {\r\n        CustomElement.cleanProps();\r\n      });\r\n    }\r\n    \r\n    checkInnerHTML(){\r\n      if (this.innerHTML && this.innerHTML.length > 0){\r\n        const filtered = []\r\n        Array.from(this.childNodes).forEach(node => {\r\n          if (node.nodeName === \"#text\"){\r\n            if (node.nodeValue.replace(/[\\s\\\\]+/g, '').length === 0){\r\n              return\r\n            }else{\r\n              filtered.push(node.nodeValue)\r\n            }\r\n           \r\n          }else{\r\n            filtered.push(node)\r\n          }\r\n        })\r\n        this.props.children = filtered\r\n      }\r\n    }\r\n    connectedCallback() {\r\n      this.checkInnerHTML();\r\n      document.adoptedStyleSheets = [...document.adoptedStyleSheets, this.sheet];\r\n      \r\n      setCurrentComponent(this);\r\n      \r\n      const cleanupEffects = [];\r\n      \r\n      const cleanup = createEffect(async () => {\r\n   \r\n        setCurrentComponent(this);\r\n        CustomElement.checkProps(this);  // Use static method to check props\r\n        \r\n        this.startTime = performance.now();\r\n        \r\n        if (this.isInitialRender) {\r\n          const t = component.call(this, this.props);\r\n          if (this.strict) {\r\n            console.warn(`Strict Mode is enabled for component \"${elementName}\". All state variables must be invoked with parentheses (e.g., 'variable()') to ensure interactions with their actual values and not the proxy objects. This mode enforces strict syntax to prevent common proxy-related issues.`);\r\n          }\r\n          if (typeof t !== \"function\") {\r\n            //throw new Error(\"Component must return a functional template.\");\r\n          }\r\n          this.template = t;\r\n          this.isInitialRender = false;\r\n        }\r\n  \r\n        let focusPath = null;\r\n        if (document.activeElement) {\r\n          const activeEl = document.activeElement;\r\n          focusPath = FocusManager.getPathToElement(activeEl);\r\n          if ((activeEl.tagName === \"INPUT\" && activeEl.getAttribute(\"type\") === \"text\") || activeEl.tagName === \"TEXTAREA\") {\r\n            FocusManager.setFocusAttributes([{name:\"selectionStart\",value:activeEl.selectionStart}]);\r\n          }\r\n        }\r\n        \r\n        try {\r\n          let result = null;\r\n          typeof this.template === \"function\" ? result = this.template(this.props) : result = this.template;\r\n          \r\n          let { strings, values } = result;\r\n\r\n          this.eventHandlers.clear();\r\n          const processedTemplate = this.processTemplate(strings, values)\r\n          //const processedTemplate = this.removeUnnecessaryWhitespace(this.processTemplate(strings, values).replace(/\\n/g, ''));\r\n\r\n          if (this.previousVdom) {\r\n            updateElement(this, processedTemplate);\r\n          } else {\r\n            this.innerHTML = processedTemplate;\r\n          }\r\n\r\n          \r\n\r\n          this.attachEventListeners();\r\n          this.previousVdom = processedTemplate;\r\n        } catch (error) {\r\n          console.error('Error in component rendering:', error);\r\n        } finally {\r\n          \r\n        }\r\n\r\n        this.endTime = performance.now();\r\n        FocusManager.setFocusPath(focusPath);\r\n      \r\n\r\n        FocusManager.restoreFocus();\r\n        CustomElement.scheduleCleanup();  // Schedule cleanup after render  // Schedule cleanup after render\r\n      });\r\n   \r\n      cleanupEffects.push(cleanup);\r\n      this.cleanupEffects = cleanupEffects;\r\n      //console.log(\"component: \", elementName, \" mounted\");\r\n      this.triggerOnMount();\r\n    }\r\n    cleanupComponentDomPool() {\r\n      const elementsToRelease = this.querySelectorAll('*');\r\n      elementsToRelease.forEach(element => {\r\n          const tagName = element.tagName.toLowerCase();\r\n          const pool = domPool.get(tagName);\r\n          if (pool) {\r\n              const index = pool.indexOf(element);\r\n              if (index !== -1) {\r\n                  pool.splice(index, 1);\r\n              }\r\n          }\r\n      });\r\n  }\r\n  removeUnnecessaryWhitespace(html) {\r\n    // Remove whitespace between tags\r\n    html = html.replace(/>\\s+</g, '><');\r\n    \r\n    // Remove leading and trailing whitespace from each line\r\n    html = html.split('\\n').map(line => line.trim()).join('');\r\n    \r\n    // Collapse multiple spaces into a single space within tags\r\n    html = html.replace(/\\s{2,}/g, ' ');\r\n    \r\n    // Remove space before self-closing tags\r\n    html = html.replace(/\\s+\\/>/g, '/>');\r\n    \r\n    // Remove space after opening tags and before closing tags\r\n    html = html.replace(/<\\s+/g, '<').replace(/\\s+>/g, '>');\r\n    \r\n    return html;\r\n  }\r\n    attachEventListeners() {\r\n      // Iterate over the event handlers\r\n      this.eventHandlers.forEach((events, id) => {\r\n        let targetElement = this.querySelector(`[${id}]`);\r\n        // Iterate over each event for the current element\r\n        events.forEach((event) => {\r\n          if (targetElement) {\r\n            try {\r\n              targetElement[event.event] = event.handler\r\n            }catch(e){\r\n              console.log(\"error in event handler: \", e)\r\n            }\r\n          }\r\n        });\r\n        //targetElement.removeAttribute(\"air_event_id\");\r\n      });\r\n    }\r\n\r\n    disconnectedCallback() {\r\n      // Clear styles\r\n      document.adoptedStyleSheets = document.adoptedStyleSheets.filter(s => s !== this.sheet);\r\n      \r\n      /** \r\n      // Clear intervals\r\n      const intervals = intervalTracker.get(this);\r\n      if (intervals) {\r\n        intervals.forEach(id => {\r\n          originalClearInterval.call(window, id);\r\n        });\r\n        intervalTracker.delete(this);\r\n      }\r\n      */\r\n      // Clear event handlers\r\n      this.eventHandlers.clear();\r\n      this.cleanupGlobalState();\r\n      // Clear state\r\n      this.state.clear();\r\n  \r\n      // Nullify references\r\n      this.previousVdom = null;\r\n      this.currentVdom = null;\r\n      this.focusElement = null;\r\n      this.childContent = null;\r\n      this.props = null;\r\n\r\n      // Clear event handlers\r\n      this.eventHandlers.forEach((events, id) => {\r\n        const element = this.querySelector(`[air_event_id=\"${id}\"]`);\r\n        if (element) {\r\n          events.forEach(event => {\r\n            element[event.event] = null;\r\n          });\r\n        }\r\n      });\r\n      this.eventHandlers.clear();\r\n      // Run cleanup effects\r\n      if (this.cleanupEffects) {\r\n        this.cleanupEffects.forEach(cleanup => cleanup.cleanup && cleanup.cleanup());\r\n      }\r\n      this.cleanupComponentDomPool();\r\n      this.cleanupSubscribers();\r\n      // Run unmount callbacks\r\n      this.triggerOnUnMount();\r\n      this.cleanupEffects = null;\r\n      const propId = CustomElement.elementPropMap.get(this);\r\n      if (propId) {\r\n        CustomElement.elementPropMap.delete(this);\r\n        CustomElement.currentPropIds.delete(propId);\r\n      }\r\n      allStates.forEach(state=>{\r\n        state.removeComponentSubscribers(this)\r\n        if (state.subscribers.size === 0){\r\n          allStates.delete(state)\r\n        }\r\n      })\r\n    }\r\n    cleanupSubscribers() {\r\n      // Clean up global state subscriptions\r\n      if (componentStateMap.has(this)) {\r\n        const globalStates = componentStateMap.get(this);\r\n        globalStates.forEach(stateId => {\r\n          const [stateProxy] = airGlobalStateHeap.get(stateId);\r\n          stateProxy.state.removeComponentSubscribers(this);\r\n        });\r\n        componentStateMap.delete(this);\r\n      }\r\n  \r\n      // Clean up local state subscriptions\r\n      if (this.localStates) {\r\n        this.localStates.forEach(state => {\r\n          state.removeComponentSubscribers(this);\r\n        });\r\n        this.localStates.clear();\r\n        this.localStates = null;\r\n      }\r\n    }\r\n    cleanupGlobalState() {\r\n      if (componentStateMap.has(this)) {\r\n        const stateIds = componentStateMap.get(this);\r\n        stateIds.forEach(id => {\r\n          if (airGlobalStateHeap && airGlobalStateHeap.has(id)) {\r\n            // Check if any other component is using this global state\r\n            let isShared = false;\r\n            if (!componentStateMap.entries || componentStateMap.entries?.length === 0) return;\r\n            for (const [component, states] of componentStateMap.entries()) {\r\n              if (component !== this && states.has(id)) {\r\n                isShared = true;\r\n                break;\r\n              }\r\n            }\r\n            if (!isShared) {\r\n              // If no other component is using this state, remove it from the global heap\r\n              airGlobalStateHeap.delete(id);\r\n            }\r\n          }\r\n        });\r\n        componentStateMap.delete(this);\r\n      }\r\n    }\r\n    updateStyles(styles) {\r\n      this.sheet.insertRule(styles);\r\n    }\r\n    triggerOnUnMount = () => {\r\n      if (this.onUnMountCallbacks.length > 0){\r\n        this.onUnMountCallbacks.forEach(cb => cb())\r\n      }else{\r\n        //console.log(`Component ${elementName} unmounted`);\r\n      }\r\n    }\r\n    triggerOnMount = () => {\r\n      if (this.onMountCallbacks.length > 0){\r\n        this.onMountCallbacks.forEach(cb => {\r\n          const returnFunc = cb()\r\n          if (returnFunc && typeof returnFunc === \"function\"){\r\n            this.onUnMountCallbacks.push(returnFunc)\r\n          }else if (returnFunc && typeof returnFunc !== \"function\"){\r\n            throw new Error(\"Invalid onMount callback. Expected function, got: \" + typeof returnFunc)\r\n          }\r\n        })\r\n      }else{\r\n        //console.log(`Component ${elementName} mounted`);\r\n      }\r\n\r\n    };\r\n    \r\n    processTemplate(strings, values) {\r\n\r\n      // Helper methods\r\n      \r\n      const isHtmlTemplate = (value) => typeof value === 'object' && value && value.htmlTemplate;\r\n      const isEventHandler = (value, string) => typeof value === 'function' && regexps.onEventRegex.test(string);\r\n      const isAirCssObject = (value) => typeof value === 'object' && value && value.$AirCss;\r\n      const isPropsObject = (value, string) => typeof value === 'object' && string.endsWith(\"props=\");\r\n      const isDerivedState = (value) => value instanceof DerivedState;\r\n      \r\n\r\n      const processEventHandler = (currentResult, value, attrName, nextString) => {\r\n        const existingId = extractAttribute(currentResult, \"air_event_id\");\r\n        const id = existingId || Math.random().toString(36).substring(2, 10).trim();\r\n        const funcId = `air_event_id=\"${id}\"`;\r\n        const existing = this.eventHandlers.get(funcId) || [];\r\n        this.eventHandlers.set(funcId, [...existing, {\"event\": attrName, \"handler\": value}]);\r\n        \r\n        // Remove the attribute name and the opening quote\r\n        currentResult = currentResult.substring(0, currentResult.length - (attrName.length + 2));\r\n\r\n        // If there's no existing ID, add it\r\n        if (!existingId) {\r\n          currentResult += ` air_event_id=\"${id}\"`;\r\n        }\r\n        // hmmmm need to think about this.\r\n        if (nextString.match(/^['\"]/)){\r\n          currentResult = currentResult.trim().replace(/['\"]$/, '');\r\n        }\r\n  \r\n        return currentResult;\r\n      };\r\n  \r\n      const processFunctionValue = (currentResult, value, string, attrName) => {\r\n        \r\n        if (isReactiveState(value?.state)) {\r\n          return currentResult + value();\r\n        }\r\n        let renderedVar = value();\r\n        if (isAirCssObject(renderedVar)) {\r\n          const className = `air-css-${Math.random().toString(36).substring(2, 10).trim()}`\r\n          const renderedCss = renderedVar.$AirCss(className);\r\n          renderedCss.psuedo ? currentResult = addClassToLastUnclosedTag(currentResult, className) : currentResult;\r\n          return currentResult + renderedCss.styles;\r\n        }\r\n        if (!renderedVar) {\r\n          return currentResult + renderedVar;\r\n        }\r\n        if (isHtmlTemplate(renderedVar)) {\r\n          return currentResult + this.processTemplate(renderedVar.strings, renderedVar.values);\r\n        }\r\n        return currentResult + renderedVar;\r\n      };\r\n  \r\n      const processArrayValue = (currentResult, value) => {\r\n        const d = [];\r\n        processNestedArray(value, item => {\r\n          if (item.htmlTemplate) {\r\n            d.push(this.processTemplate(item.strings, item.values));\r\n          }else if (item instanceof HTMLElement){\r\n            d.push(item.outerHTML)\r\n          }\r\n          else{\r\n            d.push(item)\r\n          }\r\n        });\r\n        \r\n        return currentResult + d.join(\"\");\r\n      };\r\n  \r\n      const processPropsObject = (currentResult, value, string, prevString) => {\r\n        if (!string.includes(\"<\")) {\r\n          string = prevString + string;\r\n        }\r\n        const tagMatch = string.match(regexps.tagMatchRegex);\r\n        let tagName = tagMatch ? tagMatch[1] : null;\r\n        if (!tagName){\r\n          tagName = currentResult.match(regexps.tagMatchRegex)[1] //this is a bit of a hack to get the tag name when the tagname text is in an expression like <{tagName}></div>\r\n        }\r\n        \r\n        const isCustomElement = customElements.get(tagName) !== undefined || tagName === \"route\" || tagName === \"router\";\r\n        if (isCustomElement) {\r\n          const existingId = extractAttribute(currentResult, \"air_props_id\");\r\n          const id = existingId || Math.random().toString(36).substring(2, 10).trim();\r\n          const funcId = `air_props_id=\"${id}\"`;\r\n          const existing = globalProps.get(id);\r\n          if (existing) {\r\n            throw new Error(\"cannot initialise more than one properties object on a component.\");\r\n          }\r\n         \r\n          if (typeof value !== \"object\"){\r\n            throw new Error(\"Invalid props object. Expected object, got: \" + typeof value)\r\n          }\r\n          globalProps.set(id, value);\r\n          return currentResult.replace(\"props=\", funcId);\r\n        }\r\n        return currentResult;\r\n      };\r\n      \r\n      \r\n      function addClassToLastUnclosedTag(html, newClass) {\r\n        const lastTagIndex = html.lastIndexOf('<');\r\n        if (lastTagIndex === -1) return html;\r\n      \r\n        const beforeTag = html.slice(0, lastTagIndex);\r\n        const tag = html.slice(lastTagIndex);\r\n      \r\n        if (tag.includes('class=')) {\r\n          return beforeTag + tag.replace(/class=[\"']?([^\"']*)[\"']?/, `class=\"$1 ${newClass}\"`);\r\n        } else {\r\n          return beforeTag + tag.replace(/^<(\\w+)/, `<$1 class=\"${newClass}\"`);\r\n        }\r\n      }\r\n      const extractAirAttribute = (str, attribute) => {\r\n        const regex = new RegExp(`${attribute}=\"([^\"]*)\"`, 'gi');\r\n        let match;\r\n        let lastMatch = null;\r\n        \r\n        while ((match = regex.exec(str)) !== null) {\r\n          lastMatch = match;\r\n        }\r\n        \r\n        return lastMatch ? lastMatch[1] : null;\r\n      }\r\n      \r\n      const processNestedArray = (array, action) => {\r\n        array.forEach(item => {\r\n            if (Array.isArray(item)) {\r\n                // If the item is an array, recurse into it\r\n                processNestedArray(item, action);\r\n            } else {\r\n                // If the item is not an array, perform the action\r\n                action(item);\r\n            }\r\n        });\r\n      }\r\n      const processValue = (currentResult, value, string, prevString, attrName, nextString) => {\r\n\r\n        if (isReactiveState(value)) {\r\n          return currentResult + value.read;\r\n        }\r\n  \r\n        if (value && value.isStateArray === true) {\r\n          return currentResult + value.get();\r\n        }\r\n        if (isReactiveState(value) || isDerivedState(value)) {\r\n          return currentResult + value.get();\r\n        }\r\n  \r\n        if (isHtmlTemplate(value)) {\r\n          return currentResult + this.processTemplate(value.strings, value.values);\r\n        }\r\n  \r\n        if (isEventHandler(value, string)) {\r\n          \r\n          return processEventHandler(currentResult, value, attrName, nextString);\r\n        }\r\n  \r\n        if (typeof value === 'function') {\r\n          const res = processFunctionValue(currentResult, value, string, attrName);\r\n          return res\r\n        }\r\n  \r\n        if (Array.isArray(value)) {\r\n          return processArrayValue(currentResult, value);\r\n        }\r\n  \r\n        if (isPropsObject(value, string)) {\r\n          return processPropsObject(currentResult, value, string, prevString);\r\n        }\r\n  \r\n        if (isAirCssObject(value)) {\r\n\r\n          const className = `air-css-${Math.random().toString(36).substring(2, 10).trim()}`\r\n          const renderedCss = value.$AirCss(className);\r\n\r\n          renderedCss.psuedo ? currentResult = addClassToLastUnclosedTag(currentResult, className) : currentResult;\r\n\r\n          return currentResult + renderedCss.styles;\r\n        }\r\n        \r\n        if (typeof value === 'object') {\r\n          if (value instanceof HTMLElement){\r\n            return currentResult + value.outerHTML;\r\n          }\r\n          \r\n          return currentResult + JSON.stringify(value);\r\n        }\r\n        \r\n        return currentResult + value;\r\n      };\r\n\r\n      // Main processTemplate logic\r\n      const template = strings.reduce((result, string, i) => {\r\n\r\n        let currentResult = result + string;\r\n\r\n        \r\n        \r\n        if (i >= values.length) {\r\n          return currentResult;\r\n        }\r\n  \r\n        const value = values[i];\r\n        const match = string.match(regexps.attributeMatchRegex);\r\n        const attrName = match ? match[match.length - 1].trim().split('=')[0] : null;\r\n\r\n        const res = processValue(currentResult, value, string, strings[i-1], attrName, strings[i+1]);\r\n        \r\n        return res;\r\n      }, '');\r\n\r\n      const r = template.replace(regexps.routeTagRegex, (match) => {\r\n        switch (match) {\r\n          case '<route': return '<air-route';\r\n          case '</route': return '</air-route';\r\n          case '<router': return '<air-router';\r\n          case '</router': return '</air-router';\r\n          default: return match;\r\n        }\r\n      });\r\n      return r\r\n    }\r\n    \r\n  }\r\n  const lintWarnings = analyzeCode(component.toString(), component.strict)\r\n\r\n  const invalid = Object.fromEntries(Object.entries(lintWarnings).map(([key, arr]) => [key, arr.filter(item => !item.valid)]));\r\n\r\n  logErrors(invalid, component.strict)\r\n  if (!customElements.get(elementName)){\r\n    customElements.define(elementName, CustomElement);\r\n  }else{\r\n    console.log(\"component \", elementName, \" already defined.\")\r\n  }\r\n  \r\n  return component;\r\n};\r\n\r\nconst strict = () => {\r\n  currentComponent.strict = true\r\n}\r\n\r\nfunction extractAttribute(str, attribute) {\r\n  const parts = str.split(/<(?!.*<)/); // Split at the last occurrence of <\r\n  //console.log(\"parts: \", parts)\r\n  const afterLastTag = parts[parts.length-1] || '';\r\n  //console.log(\"afterLastTag: \", afterLastTag)\r\n  const regex = new RegExp(`${attribute}=\"([^\"]*)\"`);\r\n  const match = afterLastTag.match(regex);\r\n  return match ? match[1] : null;\r\n}\r\n\r\nconst MAX_POOL_SIZE = 100; // Adjust based on your needs\r\nconst domPool = new Map();\r\n\r\nfunction getPooledElement(tagName) {\r\n    if (!domPool.has(tagName)) {\r\n        domPool.set(tagName, []);\r\n    }\r\n    const pool = domPool.get(tagName);\r\n    return pool.pop() || document.createElement(tagName);\r\n}\r\n\r\nfunction releaseElement(element) {\r\n    element.removeAttribute('key');\r\n    element.innerHTML = '';\r\n    // Remove all event listeners\r\n    const clone = element.cloneNode(false);\r\n    const tagName = clone.tagName.toLowerCase();\r\n    const pool = domPool.get(tagName) || [];\r\n    if (pool.length < MAX_POOL_SIZE) {\r\n        pool.push(clone);\r\n        domPool.set(tagName, pool);\r\n    }\r\n}\r\n//setInterval(cleanupDomPool, 60000); // Clean up every minute\r\nfunction removeBlankTextNodes(element) {\r\n  [...element.childNodes].forEach(node => {\r\n    if (node.nodeType === 3 && !node.nodeValue.trim()) {\r\n      node.remove();\r\n    } else if (node.nodeType === 1) {\r\n      removeBlankTextNodes(node);\r\n    }\r\n  });\r\n}\r\nfunction updateElement(targetElement, newHtmlString) {\r\n \r\n  const fragment = document.createDocumentFragment();\r\n  const tempDiv = document.createElement('div');\r\n  tempDiv.innerHTML = newHtmlString.replace(/\\n/g, '');\r\n  while (tempDiv.firstChild) {\r\n    if (tempDiv.firstChild.nodeType === Node.TEXT_NODE && tempDiv.firstChild.nodeValue.trim() === \"\") {\r\n      tempDiv.removeChild(tempDiv.firstChild)\r\n      continue\r\n    }\r\n    fragment.appendChild(tempDiv.firstChild);\r\n  }\r\n  const t = targetElement.cloneNode(false);\r\n  Array.from(fragment.childNodes).forEach(child => t.appendChild(child));\r\n  const newTemplate = t;\r\n  removeBlankTextNodes(newTemplate)\r\n  removeBlankTextNodes(targetElement)\r\n  const isCustomElement = (e) => e.tagName?.includes('-');\r\n  \r\n  function updateAttributes(current, updated) {\r\n\r\n    const currentAttrs = current.attributes;\r\n    const updatedAttrs = updated.attributes;\r\n    \r\n    let changed = false;\r\n    \r\n    for (let i = 0; i < updatedAttrs.length; i++) {\r\n      const attr = updatedAttrs[i];\r\n      if (current.getAttribute(attr.name) !== attr.value) {\r\n        current.setAttribute(attr.name, attr.value);\r\n        changed = true;\r\n      }\r\n    }\r\n  \r\n    for (let i = 0; i < currentAttrs.length; i++) {\r\n      const attr = currentAttrs[i];\r\n      if (!updated.hasAttribute(attr.name)) {\r\n        current.removeAttribute(attr.name);\r\n        changed = true;\r\n      }\r\n    }\r\n\r\n    return changed;\r\n  }\r\n\r\n  function updateDom(current, updated, isRoot = false) {\r\n    if (current.nodeType === Node.TEXT_NODE && current.nodeValue.trim() === \"\") {\r\n      return;\r\n    }\r\n    \r\n    if (current.nodeType === Node.TEXT_NODE && updated.nodeType === Node.TEXT_NODE) {\r\n      if (current.nodeValue !== updated.nodeValue) {\r\n        current.nodeValue = updated.nodeValue;\r\n      }\r\n      return;\r\n    }\r\n\r\n    const currentIsCustom = isCustomElement(current);\r\n    const updatedIsCustom = isCustomElement(updated);\r\n\r\n    if (!isRoot && (currentIsCustom || updatedIsCustom)) {\r\n      if (current.nodeName === updated.nodeName) {\r\n        if (current.getAttribute(\"air_props_id\")) {\r\n          const currentProps = globalProps.get(current.getAttribute(\"air_props_id\"));\r\n          const updatedProps = globalProps.get(updated.getAttribute(\"air_props_id\"));\r\n          if (currentProps !== updatedProps) {\r\n            const newElement = getPooledElement(updated.nodeName);\r\n            updateAttributes(newElement, updated);\r\n            current.parentNode.replaceChild(newElement, current);\r\n            releaseElement(current);\r\n          } else {\r\n            updateAttributes(current, updated);\r\n          }\r\n        }\r\n        return;\r\n      } else {\r\n        const newElement = getPooledElement(updated.nodeName);\r\n        updateAttributes(newElement, updated);\r\n        current.parentNode.replaceChild(newElement, current);\r\n        releaseElement(current);\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (current.nodeName !== updated.nodeName) {\r\n      const newElement = updated.cloneNode(true);\r\n      current.parentNode.replaceChild(newElement, current);\r\n      if (current.nodeType === Node.ELEMENT_NODE) {\r\n        releaseElement(current);\r\n      }\r\n      return;\r\n    }\r\n\r\n    if (current.nodeType === Node.ELEMENT_NODE) {\r\n      const attributesChanged = updateAttributes(current, updated);\r\n      \r\n      // If attributes didn't change and the node has no children, we can skip further processing\r\n      if (!attributesChanged && !current.firstChild && !updated.firstChild) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    const currentChildren = current.childNodes;\r\n    const updatedChildren = updated.childNodes;\r\n    \r\n    let currentIndex = 0;\r\n    let updatedIndex = 0;\r\n\r\n    while (updatedIndex < updatedChildren.length) {\r\n      const updatedChild = updatedChildren[updatedIndex];\r\n      \r\n      if (currentIndex >= currentChildren.length) {\r\n        current.appendChild(updatedChild.cloneNode(true));\r\n        updatedIndex++;\r\n      } else {\r\n        const currentChild = currentChildren[currentIndex];\r\n        if (currentChild.nodeName === updatedChild.nodeName) {\r\n          updateDom(currentChild, updatedChild);\r\n          currentIndex++;\r\n          updatedIndex++;\r\n        } else {\r\n          current.insertBefore(updatedChild.cloneNode(true), currentChild);\r\n          updatedIndex++;\r\n        }\r\n      }\r\n    }\r\n\r\n    while (currentChildren.length > updatedChildren.length) {\r\n      const removedChild = current.lastChild;\r\n      current.removeChild(removedChild);\r\n      if (removedChild.nodeType === Node.ELEMENT_NODE) {\r\n        releaseElement(removedChild);\r\n      }\r\n    }\r\n  }\r\n\r\n  updateDom(targetElement, newTemplate, true);\r\n}\r\n\r\n\r\nconst airCss = (styles) => {\r\n  const parse = (id) => {\r\n    //console.log(\"airCss: \", styles)\r\n    if (typeof styles === \"function\"){\r\n      console.log(\"functional style: \") //hmmmm need to think about this.\r\n    }\r\n    let styleString = '';\r\n    \r\n    const processGroup = (group, properties) => {\r\n      if (typeof properties !== \"object\"){\r\n        if (isValidCSSProperty(group)){\r\n\r\n          group = group.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\r\n          if (typeof properties === \"function\"){\r\n            properties = properties()\r\n          }\r\n        }\r\n        //unary style like opacity. \r\n        styleString += `${group}: ${properties.toString().replaceAll('\"',\"'\")}; `;\r\n        //return\r\n      }else{\r\n        \r\n        Object.keys(properties).forEach(property => {\r\n        \r\n          let value = properties[property];\r\n  \r\n          if (isReactiveState(value)){\r\n  \r\n            value = value\r\n            //return\r\n          }\r\n          \r\n          if (typeof value === 'function') {\r\n  \r\n            value = value();\r\n          }\r\n          if (group === \"font\" && property === \"color\"){\r\n            styleString += `${property}: ${value.toString().replaceAll('\"',\"'\")}; `;\r\n          }else{\r\n  \r\n            styleString += `${group}-${property}: ${value.toString().replaceAll('\"',\"'\")}; `;\r\n          }\r\n          \r\n        });\r\n      }\r\n      \r\n      \r\n    };\r\n    const processPsuedoElement = (group, properties) =>{\r\n\r\n      if (!currentComponent){\r\n        throw new Error(\"Invalid component context\")\r\n      }\r\n      \r\n      const styleRules = []\r\n      \r\n      Object.keys(properties).forEach(property => {\r\n        let value = properties[property];\r\n        if (typeof group === \"string\" && typeof property === \"string\" && group.startsWith(\"_\")){}\r\n\r\n        if (typeof value !== \"object\"){\r\n          //unary\r\n          if (isValidCSSProperty(property)){\r\n            property = property.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\r\n            if (typeof value === \"function\"){\r\n              value = value()\r\n            }\r\n\r\n            styleRules.push({property, value})\r\n          }\r\n\r\n        }else{\r\n          Object.keys(value).forEach(psuedoProperty=>{\r\n            let psuedoValue = value[psuedoProperty]\r\n              \r\n            if (typeof psuedoValue === 'function') {\r\n  \r\n              psuedoValue = psuedoValue();\r\n            }\r\n            if (property === \"font\" && psuedoProperty === \"color\"){\r\n\r\n              styleRules.push({property:psuedoProperty, value:psuedoValue})\r\n            }if (group.startsWith(\"_\")){\r\n              styleRules.push({property:`${group}${property}-${psuedoProperty}`, value:psuedoValue})\r\n            }\r\n            else{\r\n              \r\n              styleRules.push({property:`${property}-${psuedoProperty}`, value:psuedoValue})\r\n\r\n            }\r\n          })\r\n        }\r\n        \r\n      });\r\n\r\n      if (styleRules.length>0){\r\n        const cssRules = generatePseudoElementCSS(styleRules, id,  group.replace(\"_\",\"\"));\r\n        \r\n        cssRules.forEach(cssRule=>{\r\n          currentComponent.updateStyles(cssRule)\r\n        })\r\n      }\r\n      \r\n    }\r\n    const isValidCSSProperty = (property) => {\r\n      // Convert camelCase to kebab-case\r\n      const kebabCaseProperty = property.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\r\n      \r\n      // Check if the property is supported\r\n      return CSS.supports(kebabCaseProperty, 'initial');\r\n    }\r\n\r\n    const generatePseudoElementCSS = (properties, id, pseudoElement) => {\r\n      \r\n      let cssRules = [];\r\n      let mainProperties = [];\r\n      let stackedProperties = {};\r\n    \r\n      // Separate main properties from stacked properties\r\n      properties.forEach(prop => {\r\n        if (prop.property.startsWith('_')) {\r\n          let [stacked, ...rest] = prop.property.slice(1).split('-');\r\n          let stackedPseudo = stacked.replace('_', ':');\r\n          let actualProperty = rest.join('-');\r\n          \r\n          if (!stackedProperties[stackedPseudo]) {\r\n            stackedProperties[stackedPseudo] = [];\r\n          }\r\n          stackedProperties[stackedPseudo].push({ property: actualProperty, value: prop.value });\r\n        } else {\r\n          mainProperties.push(prop);\r\n        }\r\n      });\r\n    \r\n      // Generate CSS for main pseudo-element\r\n      if (mainProperties.length > 0) {\r\n        let selector = `.${id}:${pseudoElement}`;\r\n        let cssString = `${selector} {`;\r\n        mainProperties.forEach(prop => {\r\n          if (prop.property === 'content'){\r\n            cssString += ` ${prop.property}: \"${prop.value}\" !important;`;\r\n          }else{\r\n            cssString += ` ${prop.property}: ${prop.value} !important;`;\r\n          }\r\n        });\r\n        cssString += ' }';\r\n        cssRules.push(cssString);\r\n      }\r\n    \r\n      // Generate CSS for stacked pseudo-elements\r\n      for (let [stackedPseudo, props] of Object.entries(stackedProperties)) {\r\n        let selector = `.${id}:${stackedPseudo}`;\r\n        let cssString = `${selector} {`;\r\n        props.forEach(prop => {\r\n          cssString += ` ${prop.property}: ${prop.value} !important;`;\r\n        });\r\n        cssString += ' }';\r\n        cssRules.push(cssString);\r\n      }\r\n    \r\n      return cssRules;\r\n    };\r\n    let psuedo = false\r\n    Object.keys(styles).forEach(group => {\r\n        if (!group.startsWith(\"_\")){\r\n          processGroup(group, styles[group]);\r\n        }else{\r\n          psuedo = true\r\n         \r\n          processPsuedoElement(group, styles[group])\r\n        }\r\n        \r\n\r\n    });\r\n    return {styles:styleString.trim(),psuedo}\r\n  };\r\n\r\n  return ()=>{return{\"$AirCss\":(id) => parse(id)}}\r\n};\r\n\r\nconst keyframes = (animation) => {\r\n  if (!animation || typeof animation !== 'object') {\r\n    throw new Error('Animation must be a non-null object');\r\n  }\r\n\r\n  const id = 'keyframes_' + Math.random().toString(36).substr(2, 9);\r\n\r\n  const convertToCSSString = (obj) => {\r\n    return Object.entries(obj)\r\n      .map(([prop, value]) => {\r\n        // If the value is a function, execute it\r\n        const computedValue = typeof value === 'function' ? value() : value;\r\n        return `${prop.replace(/[A-Z]/g, m => '-' + m.toLowerCase())}: ${computedValue};`;\r\n      })\r\n      .join(' ');\r\n  };\r\n\r\n  const processKeyframe = (keyframe) => {\r\n    if (typeof keyframe === 'function') {\r\n      return convertToCSSString(keyframe());\r\n    }\r\n    return convertToCSSString(keyframe);\r\n  };\r\n\r\n  const cssString = `@keyframes ${id} {\r\n    ${Object.entries(animation)\r\n      .map(([key, value]) => `${key} { ${processKeyframe(value)} }`)\r\n      .join('\\n    ')}\r\n  }`;\r\n\r\n  let sheet;\r\n  try {\r\n    sheet = new CSSStyleSheet();\r\n    sheet.insertRule(cssString);\r\n  } catch (error) {\r\n    console.error('Failed to create or insert keyframe rule:', error);\r\n    return ''; // Return empty string if failed\r\n  }\r\n\r\n  if (typeof document !== 'undefined' && document.adoptedStyleSheets) {\r\n    document.adoptedStyleSheets = [...document.adoptedStyleSheets, sheet];\r\n  } else if (typeof document !== 'undefined') {\r\n    const styleElement = document.createElement('style');\r\n    styleElement.textContent = cssString;\r\n    document.head.appendChild(styleElement);\r\n  }\r\n\r\n  // Return the animation name directly\r\n  return (options) => {\r\n    return `${id} ${options}`\r\n  }\r\n  return id;\r\n};\r\nconst rulesForCssString = (cssString) => {\r\n  var doc = document.implementation.createHTMLDocument(\"\"),\r\n  styleElement = document.createElement(\"style\");\r\n\r\n  styleElement.textContent = cssString;\r\n  // the style will only be parsed once it is added to a document\r\n  doc.body.appendChild(styleElement);\r\n\r\n  return styleElement.sheet.cssRules;\r\n};\r\nfunction prefixCssRules(cssRules, prefix) {\r\n  for (let i = 0; i < cssRules.length; i++) {\r\n    const rule = cssRules[i];\r\n  \r\n    // Check if it's a style rule (like .aClass)\r\n    if (rule.type === CSSRule.STYLE_RULE) {\r\n      console.log(rule)\r\n      // Update the selector to include the prefix\r\n      rule.selectorText = `${prefix} ${rule.selectorText}`;\r\n\r\n      // Update any animation-name property to use the prefixed name\r\n      if (rule.style.animationName) {\r\n        rule.style.animationName = `${prefix}_${rule.style.animationName}`;\r\n      }\r\n    } \r\n    \r\n    // Check if it's a keyframes rule (like @keyframes myAnimation)\r\n    else if (rule.type === CSSRule.KEYFRAMES_RULE) {\r\n      // Prefix the keyframes rule name\r\n      rule.name = `${prefix}_${rule.name}`;\r\n\r\n      // Update each keyframe rule inside the keyframes\r\n      for (let j = 0; j < rule.cssRules.length; j++) {\r\n        const keyframe = rule.cssRules[j];\r\n\r\n        // Ensure any references to animation names are updated\r\n        if (keyframe.style.animationName) {\r\n          keyframe.style.animationName = `${prefix}_${keyframe.style.animationName}`;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Handle other possible rule types (like media queries, supports, etc.)\r\n    if (rule.cssRules && rule.cssRules.length > 0) {\r\n      // Recursively handle nested rules\r\n      prefixCssRules(rule.cssRules, prefix);\r\n    }\r\n  }\r\n}\r\nconst style = (cssString) => {\r\n  const rules = rulesForCssString(cssString);\r\n  console.log(rules)\r\n  prefixCssRules(rules, currentComponent.tagName.toLowerCase())\r\n  console.log(rules,currentComponent.tagName)\r\n  const stylesheet = currentComponent.sheet;\r\n  for (let i = 0; i < rules.length; i++) {\r\n    const rule = rules[i];\r\n    \r\n    // Add the rule's text to the adopted stylesheet\r\n    stylesheet.insertRule(rule.cssText, stylesheet.cssRules.length);\r\n  }\r\n \r\n};\r\n\r\n// Routing\r\nlet routes = [];\r\nconst [currentPath, setCurrentPath] = createState(window.location.pathname);\r\nconst handleNavigation = (event) => {\r\n  event.preventDefault();\r\n  const path = event.target.getAttribute('href');\r\n  window.history.pushState({}, '', path);\r\n  setCurrentPath(path);\r\n};\r\nfunction matchPath(path) {\r\n  for (let route of routes) {\r\n      // Create an array of all valid paths for the route, including aliases\r\n      let pathsToMatch = [route.path];\r\n      if (route.aliases) {\r\n          pathsToMatch = pathsToMatch.concat(route.aliases);\r\n      }\r\n\r\n      for (let pathToMatch of pathsToMatch) {\r\n          const routeParts = pathToMatch.split('/');\r\n          const pathParts = path.split('/');\r\n\r\n          if (routeParts.length !== pathParts.length) {\r\n              continue;\r\n          }\r\n\r\n          let isMatch = true;\r\n          let params = {};\r\n\r\n          for (let i = 0; i < routeParts.length; i++) {\r\n              if (routeParts[i].startsWith(':')) {\r\n                  params[routeParts[i].substring(1)] = pathParts[i];\r\n              } else if (routeParts[i] !== pathParts[i] && routeParts[i] !== '*') {\r\n                  isMatch = false;\r\n                  break;\r\n              }\r\n          }\r\n\r\n          if (isMatch) {\r\n              return { ...route, params };\r\n          }\r\n      }\r\n  }\r\n\r\n  return null; // No match found\r\n}\r\n\r\nconst AirRouter = AirComponent('air-router', function(RouterProps) {\r\n\r\n  window.addEventListener('popstate', () => {\r\n    setCurrentPath(window.location.pathname);\r\n  });\r\n\r\n  const currentRoute = () => {\r\n    const xmatch = matchPath(currentPath()) || routes.find(route => route.path === '*');\r\n    if (typeof xmatch.component !== 'string') {\r\n      throw new Error(`Invalid route component. Expected string, got: ${typeof xmatch.component}, please use the registered name of the component.`);\r\n    }\r\n    return xmatch;\r\n  };\r\n  \r\n  return () => {\r\n    const route = currentRoute();\r\n    const componentName = route && route.component ? route.component : '';\r\n    const routeParams = route ? route.params : {};\r\n    // Render\r\n    return html`\r\n         <${componentName} props=${{ RouteParams: routeParams, RouterProps }}></${componentName}>\r\n\r\n    `;\r\n  };\r\n});\r\n\r\n\r\nconst AirRoute = AirComponent('air-route', function(props) {\r\n  return () => html`\r\n    <a href=\"${this.getAttribute(\"href\")}\" onclick=\"${handleNavigation}\">${props.children}</a>\r\n  `;\r\n});\r\n\r\nconst Router = {\r\n  Router: AirRouter,\r\n  Routes: (newRoutes) => {\r\n    const flattenRoutes = (routes, parentPath = '') => \r\n      routes.flatMap(route => {\r\n        const fullPath = parentPath ? `${parentPath}/${route.path}` : route.path;\r\n        const flattenedRoute = { ...route, path: fullPath };\r\n        delete flattenedRoute.children;\r\n  \r\n        if (route.children) {\r\n          return [flattenedRoute, ...flattenRoutes(route.children, fullPath)];\r\n        }\r\n  \r\n        return flattenedRoute;\r\n      });\r\n  \r\n    // Flatten all routes including the top-level ones\r\n    routes = flattenRoutes(newRoutes);\r\n  },\r\n  Route:AirRoute\r\n}\r\n\r\nclass QueryCache {\r\n  constructor() {\r\n    this.queries = new Map();\r\n    this.queryIntervals = new WeakMap();\r\n  }\r\n\r\n  setQuery(queryKey, data, options = {}) {\r\n    const { cacheTime = 5 * 60 * 1000, staleTime = 0 } = options;\r\n    this.queries.set(queryKey, {\r\n      data,\r\n      timestamp: Date.now(),\r\n      cacheTime,\r\n      staleTime,\r\n    });\r\n  }\r\n\r\n  getQuery(queryKey) {\r\n    const query = this.queries.get(queryKey);\r\n    if (!query) return null;\r\n\r\n    const now = Date.now();\r\n    if (now - query.timestamp > query.cacheTime) {\r\n      this.queries.delete(queryKey);\r\n      return null;\r\n    }\r\n\r\n    return query;\r\n  }\r\n\r\n  invalidateQueries(predicate) {\r\n    for (const [key, query] of this.queries.entries()) {\r\n      if (predicate(query, key)) {\r\n        this.queries.delete(key);\r\n      }\r\n    }\r\n  }\r\n\r\n  clear() {\r\n    this.queries.clear();\r\n  }\r\n\r\n  setQueryInterval(component, queryKey, intervalId) {\r\n    if (!this.queryIntervals.has(component)) {\r\n      this.queryIntervals.set(component, new Map());\r\n    }\r\n    this.queryIntervals.get(component).set(queryKey, intervalId);\r\n  }\r\n\r\n  clearQueryIntervals(component) {\r\n    const intervals = this.queryIntervals.get(component);\r\n    if (intervals) {\r\n      intervals.forEach(intervalId => clearInterval(intervalId));\r\n      this.queryIntervals.delete(component);\r\n    }\r\n  }\r\n}\r\n\r\nconst queryCache = new QueryCache();\r\n\r\nconst createQuery = (queryKey, queryFn, options = {}) => {\r\n  const { cacheTime = 5 * 60 * 1000, staleTime = 0, refetchInterval } = options;\r\n  const [data, setData] = createState(null);\r\n  const [isLoading, setIsLoading] = createState(true);\r\n  const [error, setError] = createState(null);\r\n\r\n  const fetchData = async (isRefetch = false) => {\r\n    if (!isRefetch) setIsLoading(true);\r\n    setError(null);\r\n    try {\r\n      const result = await queryFn();\r\n      setData(result);\r\n      queryCache.setQuery(queryKey, result, { cacheTime, staleTime });\r\n    } catch (err) {\r\n      setError(err);\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  };\r\n\r\n  // Check cache or fetch data\r\n  const cachedQuery = queryCache.getQuery(queryKey);\r\n  if (cachedQuery) {\r\n    setData(cachedQuery.data);\r\n    setIsLoading(false);\r\n    if (Date.now() - cachedQuery.timestamp > cachedQuery.staleTime) {\r\n      fetchData(true);\r\n    }\r\n  } else {\r\n    fetchData();\r\n  }\r\n\r\n  // Set up refetch interval if specified\r\n  if (refetchInterval) {\r\n    const intervalId = setInterval(() => fetchData(true), refetchInterval);\r\n    queryCache.setQueryInterval(currentComponent, queryKey, intervalId);\r\n\r\n    // Clean up interval on component unmount\r\n    onUnMount(() => {\r\n      clearInterval(intervalId);\r\n      queryCache.clearQueryIntervals(currentComponent);\r\n    });\r\n  }\r\n\r\n  const refetch = () => fetchData(true);\r\n\r\n  return { data, isLoading, error, refetch };\r\n};\r\n\r\nconst invalidateQueries = (predicate) => queryCache.invalidateQueries(predicate);\r\nconst clearQueryCache = () => queryCache.clear();\n\n//# sourceURL=webpack://record-view/./node_modules/@air-apps/air-js/lib/air.js?");

/***/ }),

/***/ "./src/components/RecordsView.js":
/*!***************************************!*\
  !*** ./src/components/RecordsView.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TreeViewAccordion: () => (/* binding */ TreeViewAccordion)\n/* harmony export */ });\n/* harmony import */ var _air_apps_air_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @air-apps/air-js */ \"./node_modules/@air-apps/air-js/lib/air.js\");\n\r\n\r\nclass ApiService {\r\n  constructor(baseUrl) {\r\n    this.baseUrl = baseUrl;\r\n  }\r\n\r\n  async getNodes(nodePaths, limit = 100, offset = 0) {\r\n    const token = PydioApi._PydioRestClient.authentications.oauth2.accessToken;\r\n    const response = await fetch(`${this.baseUrl}/a/tree/stats`, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        'Authorization': 'Bearer ' + token\r\n      },\r\n      body: JSON.stringify({\r\n        NodePaths: nodePaths,\r\n        Limit: limit,\r\n        Offset: offset,\r\n        AllMetaProviders: true,\r\n      }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      throw new Error('Network response was not ok');\r\n    }\r\n\r\n    return response.json();\r\n  }\r\n\r\n  static buildHierarchy(nodes, parentPath = '') {\r\n    const hierarchy = [];\r\n    const nodeMap = new Map();\r\n\r\n    nodes.forEach(node => {\r\n      const relativePath = node.Path.substring(parentPath.length);\r\n      const parts = relativePath.split('/').filter(Boolean);\r\n      \r\n      const record = {\r\n        id: node.Uuid,\r\n        title: parts[parts.length - 1],\r\n        path: node.Path,\r\n        type: node.Type,\r\n        children: [],\r\n        MetaStore: node.MetaStore\r\n      };\r\n\r\n      nodeMap.set(node.Path, record);\r\n\r\n      if (parts.length === 1) {\r\n        hierarchy.push(record);\r\n      } else {\r\n        const parentNodePath = node.Path.substring(0, node.Path.lastIndexOf('/'));\r\n        const parentNode = nodeMap.get(parentNodePath);\r\n        if (parentNode) {\r\n          parentNode.children.push(record);\r\n        }\r\n      }\r\n    });\r\n\r\n    return hierarchy;\r\n  }\r\n}\r\n\r\nconst TreeNode = (0,_air_apps_air_js__WEBPACK_IMPORTED_MODULE_0__.AirComponent)('tree-node', function(props) {\r\n  const [isExpanded, setIsExpanded] = (0,_air_apps_air_js__WEBPACK_IMPORTED_MODULE_0__.createState)(false);\r\n\r\n  const toggleExpand = () => {\r\n    setIsExpanded(!isExpanded());\r\n  };\r\n\r\n  const nodeStyles = (0,_air_apps_air_js__WEBPACK_IMPORTED_MODULE_0__.airCss)({\r\n    display: 'flex',\r\n    flexDirection: 'column',\r\n    marginLeft: '20px',\r\n    cursor: 'pointer',\r\n    _hover: {\r\n      backgroundColor: '#f0f0f0'\r\n    }\r\n  });\r\n\r\n  const titleStyles = (0,_air_apps_air_js__WEBPACK_IMPORTED_MODULE_0__.airCss)({\r\n    display: 'flex',\r\n    alignItems: 'center',\r\n    padding: '5px'\r\n  });\r\n\r\n  return () => (0,_air_apps_air_js__WEBPACK_IMPORTED_MODULE_0__.html)`\r\n    <div style=${nodeStyles()}>\r\n      <div style=${titleStyles()} onclick=${toggleExpand}>\r\n        ${props.node.children.length > 0 ? (isExpanded() ? '▼' : '▶') : '•'}\r\n        ${props.node.title}\r\n      </div>\r\n      ${isExpanded() && props.node.children.length > 0 ? (0,_air_apps_air_js__WEBPACK_IMPORTED_MODULE_0__.html)`\r\n        <div>\r\n          ${props.node.children.map(child => (0,_air_apps_air_js__WEBPACK_IMPORTED_MODULE_0__.html)`\r\n            <tree-node props=${{ node: child }}></tree-node>\r\n          `)}\r\n        </div>\r\n      ` : ''}\r\n    </div>\r\n  `;\r\n});\r\n\r\nconst TreeViewAccordion = (0,_air_apps_air_js__WEBPACK_IMPORTED_MODULE_0__.AirComponent)('treeview-accordion', function() {\r\n  const apiService = new ApiService('https://www.curate.penwern.co.uk');\r\n  \r\n  const { data: records, isLoading, error, refetch } = (0,_air_apps_air_js__WEBPACK_IMPORTED_MODULE_0__.createQuery)(\r\n    'initialRecords',\r\n    async () => {\r\n      const response = await apiService.getNodes(['appraisal/*']);\r\n      return ApiService.buildHierarchy(response.Nodes, 'appraisal/');\r\n    },\r\n    {\r\n      cacheTime: 5 * 60 * 1000, // 5 minutes\r\n      staleTime: 60 * 1000, // 1 minute\r\n      refetchInterval: 5 * 60 * 1000 // Refetch every 5 minutes\r\n    }\r\n  );\r\n\r\n  const containerStyles = (0,_air_apps_air_js__WEBPACK_IMPORTED_MODULE_0__.airCss)({\r\n    fontFamily: 'Arial, sans-serif',\r\n    maxWidth: '800px',\r\n    margin: '0 auto',\r\n    padding: '20px'\r\n  });\r\n\r\n  return () => (0,_air_apps_air_js__WEBPACK_IMPORTED_MODULE_0__.html)`\r\n    <div style=${containerStyles()}>\r\n      <h2>TreeView Accordion</h2>\r\n      ${isLoading() ? (0,_air_apps_air_js__WEBPACK_IMPORTED_MODULE_0__.html)`\r\n        <p>Loading...</p>\r\n      ` : error() ? (0,_air_apps_air_js__WEBPACK_IMPORTED_MODULE_0__.html)`\r\n        <p>Error: ${error().message}</p>\r\n        <button onclick=${refetch}>Retry</button>\r\n      ` : (0,_air_apps_air_js__WEBPACK_IMPORTED_MODULE_0__.html)`\r\n        ${records().map(record => (0,_air_apps_air_js__WEBPACK_IMPORTED_MODULE_0__.html)`\r\n          <tree-node props=${{ node: record }}></tree-node>\r\n        `)}\r\n      `}\r\n    </div>\r\n  `;\r\n});\n\n//# sourceURL=webpack://record-view/./src/components/RecordsView.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _components_RecordsView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/RecordsView */ \"./src/components/RecordsView.js\");\n\n\n//# sourceURL=webpack://record-view/./src/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;